<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>亚马逊棋 完整版</title>
<style>
body { font-family: sans-serif; display:flex; flex-direction:column; align-items:center; margin-top:20px; }
#chessboard { display:grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8,60px); }
.cell { width:60px; height:60px; border:1px solid #333; text-align:center; line-height:60px; font-size:32px; cursor:pointer; }
button { margin:5px; padding:10px; font-size:16px; }
#message { margin-top:10px; font-weight:bold; }
</style>
</head>
<body>
<h2>亚马逊棋 网页完整版</h2>
<div id="chessboard"></div>
<div>
<button onclick="newGame()">新游戏</button>
<button onclick="undo()">悔棋</button>
</div>
<div id="message"></div>

<script>
// ---------------- 基本设置 ----------------
const SIZE = 8;
const dr = [1,-1,0,0,1,1,-1,-1];
const dc = [0,0,1,-1,1,-1,1,-1];

let board = []; // 当前棋盘
let stepFrom=[], stepTo=[], stepArrow=[]; // 棋谱记录
let step = 0;
let turn = 'B'; // 当前轮到谁
let Cpu = 'W';
let selectedFrom = null, selectedTo = null, selectedArrow = null;
let fromSelected = false;
let hinting=false, finishStep=true;

// ---------------- 图标 ----------------
const ICONS = { B:'♟', W:'♙', X:'✖' };

// ---------------- 初始化棋盘 ----------------
function prepare(){
    board = Array(SIZE).fill(0).map(()=>Array(SIZE).fill('.'));
    board[2][0]='B'; board[0][2]='B'; board[0][5]='B'; board[2][7]='B';
    board[5][0]='W'; board[7][2]='W'; board[7][5]='W'; board[5][7]='W';
    stepFrom=[]; stepTo=[]; stepArrow=[]; step=0;
    turn='B'; selectedFrom=selectedTo=selectedArrow=null; fromSelected=false;
    renderBoard(); setMessage("玩家 "+turn+" 行棋");
}

// ---------------- 渲染棋盘 ----------------
function renderBoard(){
    const boardDiv=document.getElementById('chessboard');
    boardDiv.innerHTML='';
    for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
            const cell=document.createElement('div');
            cell.classList.add('cell');
            cell.innerText=ICONS[board[r][c]]||'';
            cell.dataset.row=r; cell.dataset.col=c;
            cell.onclick=cellClicked;
            boardDiv.appendChild(cell);
        }
    }
}

// ---------------- 提示信息 ----------------
function setMessage(msg){ document.getElementById('message').innerText=msg; }

// ---------------- 辅助函数 ----------------
function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

function isClearPath(from,to){
    let drow=to.r-from.r, dcol=to.c-from.c;
    if(!(drow===0||dcol===0||Math.abs(drow)===Math.abs(dcol))) return false;
    let stepR=drow===0?0:(drow>0?1:-1), stepC=dcol===0?0:(dcol>0?1:-1);
    let r=from.r+stepR, c=from.c+stepC;
    while(r!==to.r || c!==to.c){
        if(!inBounds(r,c) || board[r][c]!='.') return false;
        r+=stepR; c+=stepC;
    }
    return board[to.r][to.c]==='.';
}

function validMove(from,to,player){
    if(!inBounds(from.r,from.c) || !inBounds(to.r,to.c)) return false;
    if(board[from.r][from.c]!==player) return false;
    if(board[to.r][to.c]!=='.') return false;
    return isClearPath(from,to);
}

function validArrow(from,to){
    if(!inBounds(to.r,to.c)) return false;
    if(board[to.r][to.c]!=='.') return false;
    return isClearPath(from,to);
}

function hasAnyMove(player){
    for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
            if(board[r][c]===player){
                for(let d=0;d<8;d++){
                    let nr=r+dr[d], nc=c+dc[d];
                    while(inBounds(nr,nc) && board[nr][nc]==='.'){ return true; nr+=dr[d]; nc+=dc[d]; }
                }
            }
        }
    }
    return false;
}

// ---------------- BFS 覆盖搜索 ----------------
function search(player){
    let dis=Array(SIZE).fill(0).map(()=>Array(SIZE).fill(10));
    let queue=[], ld=[], lr=[], lc=[];
    let start=1, end=0;
    for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
            if(board[r][c]===player){
                end++; ld[end]=0; lr[end]=r; lc[end]=c;
            }
        }
    }
    while(start<=end){
        let now={r:lr[start], c:lc[start]}; start++;
        for(let r2=0;r2<SIZE;r2++){
            for(let c2=0;c2<SIZE;c2++){
                let to={r:r2,c:c2};
                if(dis[r2][c2]===10 && validMove(now,to,player)){
                    end++; ld[end]=ld[start-1]+1; lr[end]=r2; lc[end]=c2;
                    dis[r2][c2]=ld[end];
                }
            }
        }
    }
    return dis;
}

// ---------------- Evaluate ----------------
function Evaluate(){
    let disB=search('B'), disW=search('W');
    let GradeB=0, GradeW=0;
    for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
            let delta=disB[r][c]-disW[r][c];
            if(delta>0) GradeW+=15; if(delta<0) GradeB+=15;
            if(delta>1) GradeW+=15; if(delta<-1) GradeB+=15;
            if(delta>2) GradeW+=10; if(delta<-2) GradeB+=10;
            if(delta>5) GradeW+=10; if(delta<-5) GradeB+=10;
        }
    }
    return Cpu==='B'? GradeB-GradeW : GradeW-GradeB;
}

// ---------------- AI 查找最优 ----------------
function findTheBest(){
    let maxGrade=-99999, maxPreGrade=-99999;
    let bestMove=null;
    for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
            if(board[r][c]===Cpu){
                for(let d=0;d<8;d++){
                    let nr=r+dr[d], nc=c+dc[d];
                    while(inBounds(nr,nc) && board[nr][nc]==='.'){
                        board[r][c]='.'; board[nr][nc]=Cpu;
                        for(let rr=0;rr<SIZE;rr++){
                            for(let cc=0;cc<SIZE;cc++){
                                if(validArrow({r:nr,c:nc},{r:rr,c:cc})){
                                    board[rr][cc]='X';
                                    let grade = Evaluate();
                                    if(grade>maxGrade){ maxGrade=grade; bestMove={from:{r,c},to:{r:nr,c:nc},arrow:{r:rr,c:cc}};}
                                    board[rr][cc]='.';
                                }
                            }
                        }
                        board[r][c]=Cpu; board[nr][nc]='.';
                        nr+=dr[d]; nc+=dc[d];
                    }
                }
            }
        }
    }
    return bestMove;
}

// ---------------- 玩家点击 ----------------
function cellClicked(e){
    let r=parseInt(e.target.dataset.row), c=parseInt(e.target.dataset.col);
    if(!fromSelected){
        if(board[r][c]===turn){ selectedFrom={r,c}; fromSelected=true; setMessage("选中棋子，选择落子"); }
    } else if(!selectedTo){
        selectedTo={r,c};
        if(!validMove(selectedFrom,selectedTo,turn)){ alert("非法落子"); selectedTo=null; return; }
        setMessage("落子完成，选择箭头");
    } else if(!selectedArrow){
        selectedArrow={r,c};
        if(!validArrow(selectedTo,selectedArrow)){ alert("非法箭头"); selectedArrow=null; return; }
        makePlayerMove();
    }
}

// ---------------- 玩家落子 ----------------
function makePlayerMove(){
    stepFrom[step]=selectedFrom; stepTo[step]=selectedTo; stepArrow[step]=selectedArrow;
    step++;
    board[selectedFrom.r][selectedFrom.c]='.'; board[selectedTo.r][selectedTo.c]=turn; board[selectedArrow.r][selectedArrow.c]='X';
    renderBoard();
    if(!hasAnyMove(turn==='B'?'W':'B')){ alert("游戏结束! 玩家 "+turn+" 获胜"); return; }
    turn = turn==='B'?'W':'B';
    selectedFrom=selectedTo=selectedArrow=null; fromSelected=false;
    setMessage("AI 思考中...");
    setTimeout(aiMove,200);
}

// ---------------- AI 执行 ----------------
function aiMove(){
    let best=findTheBest();
    if(!best){ alert("游戏结束! 玩家 "+(turn==='B'?'W':'B')+" 获胜"); return; }
    stepFrom[step]=best.from; stepTo[step]=best.to; stepArrow[step]=best.arrow; step++;
    board[best.from.r][best.from.c]='.'; board[best.to.r][best.to.c]=turn; board[best.arrow.r][best.arrow.c]='X';
    renderBoard();
    if(!hasAnyMove(turn==='B'?'W':'B')){ alert("游戏结束! 玩家 "+turn+" 获胜"); return; }
    turn = turn==='B'?'W':'B'; setMessage("玩家 "+turn+" 行棋");
}

// ---------------- 新游戏 ----------------
function newGame(){ prepare(); }

// ---------------- 悔棋 ----------------
function undo(){
    if(step<1) return;
    step--; let f=stepFrom[step], t=stepTo[step], a=stepArrow[step];
    board[f.r][f.c]=turn; board[t.r][t.c]='.'; board[a.r][a.c]='.';
    turn=turn==='B'?'W':'B';
    renderBoard(); setMessage("玩家 "+turn+" 行棋");
}

// ---------------- 启动 ----------------
prepare();
</script>
</body>
</html>
